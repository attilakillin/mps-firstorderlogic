package FirstOrderLogic.generator.generator.translate;

/*Generated by MPS */

import jetbrains.mps.generator.runtime.Generated;
import jetbrains.mps.generator.impl.query.QueryProviderBase;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.generator.template.BaseMappingRuleContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import jetbrains.mps.generator.template.PropertyMacroContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.generator.template.SourceSubstituteMacroNodeContext;
import jetbrains.mps.generator.template.SourceSubstituteMacroNodesContext;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.generator.template.MappingScriptContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.Map;
import jetbrains.mps.generator.impl.query.ReductionRuleCondition;
import java.util.HashMap;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.generator.impl.query.QueryKey;
import jetbrains.mps.generator.template.ReductionRuleQueryContext;
import jetbrains.mps.generator.impl.GenerationFailureException;
import jetbrains.mps.generator.impl.query.ScriptCodeBlock;
import jetbrains.mps.generator.impl.query.SourceNodeQuery;
import jetbrains.mps.generator.impl.query.QueryKeyImpl;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.generator.impl.query.SourceNodesQuery;
import java.util.Collection;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.generator.impl.query.PropertyValueQuery;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.generator.impl.query.InlineSwitchCaseCondition;
import jetbrains.mps.generator.template.InlineSwitchCaseContext;
import jetbrains.mps.lang.smodel.ConceptSwitchIndex;
import jetbrains.mps.lang.smodel.ConceptSwitchIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;

@Generated
public class QueriesGenerated extends QueryProviderBase {
  private static final Logger LOG = LogManager.getLogger(QueriesGenerated.class);
  public QueriesGenerated() {
    super(1);
  }
  public static boolean rule_Condition_0_0(final BaseMappingRuleContext _context) {
    return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(_context.getNode()))), CONCEPTS.KnowledgeBaseEntry$HX);
  }
  public static boolean rule_Condition_0_1(final BaseMappingRuleContext _context) {
    return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(_context.getNode()))), CONCEPTS.KnowledgeBaseEntry$HX);
  }
  public static boolean rule_Condition_16_0(final BaseMappingRuleContext _context) {
    if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(_context.getNode()))), CONCEPTS.KnowledgeBaseEntry$HX)) {
      LoggingRuntime.logMsgView(Level.WARN, "Ignoring negated atomic statement stated as fact! If your knowledge base also contains the positive form of this statement, then the knowledge base may be inconsistent!", QueriesGenerated.class, null, null);
      return true;
    }
    return false;
  }
  public static boolean rule_Condition_17_0(final BaseMappingRuleContext _context) {
    return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(_context.getNode()))), CONCEPTS.KnowledgeBaseEntry$HX);
  }
  public static Object propertyMacro_GetValue_0_0(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_0_1(final PropertyMacroContext _context) {
    return SPropertyOperations.getInteger(_context.getNode(), PROPS.arity$TURW);
  }
  public static Object propertyMacro_GetValue_0_2(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_0_3(final PropertyMacroContext _context) {
    return SPropertyOperations.getInteger(_context.getNode(), PROPS.arity$91hq);
  }
  public static Object propertyMacro_GetValue_0_4(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), LINKS.ref$3iQK), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_0_5(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), LINKS.ref$3iQK), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_0_6(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), LINKS.ref$3iQK), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_1_0(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(_context.getNode(), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_4_0(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), LINKS.predicate$FL91), PROPS.name$MnvL);
  }
  public static Object propertyMacro_GetValue_9_0(final PropertyMacroContext _context) {
    return SPropertyOperations.getString(SLinkOperations.getTarget(_context.getNode(), LINKS.predicate$FL91), PROPS.name$MnvL);
  }
  public static SNode sourceNodeQuery_0_0(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.left$tEgL);
  }
  public static SNode sourceNodeQuery_0_1(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.right$g53S);
  }
  public static SNode sourceNodeQuery_8_0(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.term1$Q5Mf);
  }
  public static SNode sourceNodeQuery_8_1(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.term2$Q6gh);
  }
  public static SNode sourceNodeQuery_10_0(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.term1$Q5Mf);
  }
  public static SNode sourceNodeQuery_10_1(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.term2$Q6gh);
  }
  public static SNode sourceNodeQuery_15_0(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.left$tEgL);
  }
  public static SNode sourceNodeQuery_15_1(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(_context.getNode(), LINKS.right$g53S);
  }
  public static SNode sourceNodeQuery_16_0(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(SNodeOperations.as(_context.getNode(), CONCEPTS.NegatedStatement$8l), LINKS.statement$pxjq);
  }
  public static SNode sourceNodeQuery_17_0(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(SNodeOperations.as(_context.getNode(), CONCEPTS.OrOperatorStatement$L5), LINKS.left$tEgL);
  }
  public static SNode sourceNodeQuery_17_1(final SourceSubstituteMacroNodeContext _context) {
    return SLinkOperations.getTarget(SNodeOperations.as(_context.getNode(), CONCEPTS.OrOperatorStatement$L5), LINKS.right$g53S);
  }
  public static Iterable<SNode> sourceNodesQuery_0_0(final SourceSubstituteMacroNodesContext _context) {
    return SLinkOperations.getChildren(_context.getNode(), LINKS.parameters$Jqsy);
  }
  public static Iterable<SNode> sourceNodesQuery_1_0(final SourceSubstituteMacroNodesContext _context) {
    List<SNode> compounds = ListSequence.fromList(new ArrayList<SNode>());
    for (SNode entry : ListSequence.fromList(SLinkOperations.getChildren(_context.getNode(), LINKS.content$_J4j)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(it)), CONCEPTS.PredicateListEntry$jl);
      }
    })) {
      ListSequence.fromList(compounds).addSequence(ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.as(entry, CONCEPTS.PredicateListEntry$jl), LINKS.predicates$26Nq)));
    }
    for (SNode entry : ListSequence.fromList(SLinkOperations.getChildren(_context.getNode(), LINKS.content$_J4j)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(it)), CONCEPTS.FunctionListEntry$3y);
      }
    })) {
      ListSequence.fromList(compounds).addSequence(ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.as(entry, CONCEPTS.FunctionListEntry$3y), LINKS.functions$euTU)));
    }
    return compounds;
  }
  public static Iterable<SNode> sourceNodesQuery_1_1(final SourceSubstituteMacroNodesContext _context) {
    List<SNode> statements = ListSequence.fromList(new ArrayList<SNode>());
    for (SNode entry : ListSequence.fromList(SLinkOperations.getChildren(_context.getNode(), LINKS.content$_J4j)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(it)), CONCEPTS.KnowledgeBaseEntry$HX);
      }
    })) {
      statements.addAll(ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.as(entry, CONCEPTS.KnowledgeBaseEntry$HX), LINKS.statements$MO7q)).toListSequence());
    }
    return statements;
  }
  public static Iterable<SNode> sourceNodesQuery_4_0(final SourceSubstituteMacroNodesContext _context) {
    return SLinkOperations.getChildren(_context.getNode(), LINKS.parameters$Ifhz);
  }
  public static Iterable<SNode> sourceNodesQuery_9_0(final SourceSubstituteMacroNodesContext _context) {
    return SLinkOperations.getChildren(_context.getNode(), LINKS.parameters$Ifhz);
  }
  public static void mappingScript_CodeBlock_2(final MappingScriptContext _context) {
    boolean show_message = false;
    boolean repeat;
    do {
      repeat = false;
      for (SNode orig : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.NegatedStatement$8l))) {
        SAbstractConcept cncpt = SNodeOperations.getConcept(SLinkOperations.getTarget(orig, LINKS.statement$pxjq));
        switch (conceptIndex.index(cncpt)) {
          case 0:
            if (true) {
              {
                // not all x -> exists (not x) 
                SNode outer = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x1bf6498e1734c76cL, "FirstOrderLogic.structure.ExistsQuantifiedStatement"));
                SLinkOperations.getChildren(outer, LINKS.quantors$jFRS).addAll(SLinkOperations.getChildren(SNodeOperations.as(SLinkOperations.getTarget(orig, LINKS.statement$pxjq), CONCEPTS.AllQuantifiedStatement$Ex), LINKS.quantors$jFRS));

                SNode negated = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, "FirstOrderLogic.structure.NegatedStatement"));
                SLinkOperations.setTarget(negated, LINKS.statement$pxjq, SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(orig, LINKS.statement$pxjq), CONCEPTS.AllQuantifiedStatement$Ex), LINKS.statement$PMeT));
                SLinkOperations.setTarget(outer, LINKS.statement$PMeT, negated);

                SNodeOperations.replaceWithAnother(orig, outer);
                repeat = true;
              }
            }
            break;
          case 1:
            if (true) {
              {
                // not (a and b) -> (not a) or (not b) 
                SNode outer = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928d5d80fL, "FirstOrderLogic.structure.OrOperatorStatement"));
                SNode left = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, "FirstOrderLogic.structure.NegatedStatement"));
                SNode right = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, "FirstOrderLogic.structure.NegatedStatement"));
                SLinkOperations.setTarget(left, LINKS.statement$pxjq, SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(orig, LINKS.statement$pxjq), CONCEPTS.AndOperatorStatement$2T), LINKS.left$tEgL));
                SLinkOperations.setTarget(right, LINKS.statement$pxjq, SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(orig, LINKS.statement$pxjq), CONCEPTS.AndOperatorStatement$2T), LINKS.right$g53S));
                SLinkOperations.setTarget(outer, LINKS.left$tEgL, left);
                SLinkOperations.setTarget(outer, LINKS.right$g53S, right);
                SNodeOperations.replaceWithAnother(orig, outer);
                repeat = true;
              }
            }
            break;
          case 2:
            if (true) {
              {
                // not exists x -> all (not x) 
                SNode outer = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20c99906L, "FirstOrderLogic.structure.AllQuantifiedStatement"));
                SLinkOperations.getChildren(outer, LINKS.quantors$jFRS).addAll(SLinkOperations.getChildren(SNodeOperations.as(SLinkOperations.getTarget(orig, LINKS.statement$pxjq), CONCEPTS.ExistsQuantifiedStatement$jU), LINKS.quantors$jFRS));

                SNode negated = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, "FirstOrderLogic.structure.NegatedStatement"));
                SLinkOperations.setTarget(negated, LINKS.statement$pxjq, SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(orig, LINKS.statement$pxjq), CONCEPTS.ExistsQuantifiedStatement$jU), LINKS.statement$PMeT));
                SLinkOperations.setTarget(outer, LINKS.statement$PMeT, negated);

                SNodeOperations.replaceWithAnother(orig, outer);
                repeat = true;
              }
            }
            break;
          case 3:
            if (true) {
              {
                SNode outer = SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(orig, LINKS.statement$pxjq), CONCEPTS.NegatedStatement$8l), LINKS.statement$pxjq);
                SNodeOperations.replaceWithAnother(orig, outer);
                repeat = true;
              }
            }
            break;
          case 4:
            if (true) {
              {
                // not (a or b) -> (not a) and (not b) 
                SNode outer = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x6996afbaab621954L, "FirstOrderLogic.structure.AndOperatorStatement"));
                SNode left = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, "FirstOrderLogic.structure.NegatedStatement"));
                SNode right = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, "FirstOrderLogic.structure.NegatedStatement"));
                SLinkOperations.setTarget(left, LINKS.statement$pxjq, SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(orig, LINKS.statement$pxjq), CONCEPTS.OrOperatorStatement$L5), LINKS.left$tEgL));
                SLinkOperations.setTarget(right, LINKS.statement$pxjq, SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(orig, LINKS.statement$pxjq), CONCEPTS.OrOperatorStatement$L5), LINKS.right$g53S));
                SLinkOperations.setTarget(outer, LINKS.left$tEgL, left);
                SLinkOperations.setTarget(outer, LINKS.right$g53S, right);
                SNodeOperations.replaceWithAnother(orig, outer);
                repeat = true;
              }
            }
            break;
          default:
        }
      }
      if (!(show_message) && repeat) {
        show_message = true;
      }
    } while (repeat);
    if (show_message) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Moving negations inward", QueriesGenerated.class, null, null);
    }
  }
  public static void mappingScript_CodeBlock_3(final MappingScriptContext _context) {
    int cnt = 0;
    for (SNode statement : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.AllQuantifiedStatement$Ex))) {
      for (SNode quant : ListSequence.fromList(SLinkOperations.getChildren(statement, LINKS.quantors$jFRS))) {
        SPropertyOperations.assign(quant, PROPS.name$MnvL, SPropertyOperations.getString(quant, PROPS.name$MnvL).concat(String.valueOf(cnt)));
        cnt++;
      }
    }
    for (SNode statement : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.ExistsQuantifiedStatement$jU))) {
      for (SNode quant : ListSequence.fromList(SLinkOperations.getChildren(statement, LINKS.quantors$jFRS))) {
        SPropertyOperations.assign(quant, PROPS.name$MnvL, SPropertyOperations.getString(quant, PROPS.name$MnvL).concat(String.valueOf(cnt)));
        cnt++;
      }
    }
    if (cnt != 0) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Standardizing variable names", QueriesGenerated.class, null, null);
    }
  }
  public static void mappingScript_CodeBlock_5(final MappingScriptContext _context) {
    boolean used = false;
    for (SNode parens : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.ParenthesesStatement$zg))) {
      SNodeOperations.replaceWithAnother(parens, SLinkOperations.getTarget(parens, LINKS.statement$TjGf));
      used = true;
    }
    if (used) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Removing parentheses", QueriesGenerated.class, null, null);
    }
  }
  public static void mappingScript_CodeBlock_6(final MappingScriptContext _context) {
    boolean show_message = false;
    boolean repeat;
    do {
      repeat = false;
      for (SNode equiv : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.EqualsOperatorStatement$S_))) {
        SNode ltr = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928f45d97L, "FirstOrderLogic.structure.ImpliesOperatorStatement"));
        SNode rtl = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928f45d97L, "FirstOrderLogic.structure.ImpliesOperatorStatement"));
        SLinkOperations.setTarget(ltr, LINKS.left$tEgL, SNodeOperations.copyNode(SLinkOperations.getTarget(equiv, LINKS.left$tEgL)));
        SLinkOperations.setTarget(ltr, LINKS.right$g53S, SNodeOperations.copyNode(SLinkOperations.getTarget(equiv, LINKS.right$g53S)));
        SLinkOperations.setTarget(rtl, LINKS.left$tEgL, SNodeOperations.copyNode(SLinkOperations.getTarget(equiv, LINKS.right$g53S)));
        SLinkOperations.setTarget(rtl, LINKS.right$g53S, SNodeOperations.copyNode(SLinkOperations.getTarget(equiv, LINKS.left$tEgL)));
        SNode wrapper = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x6996afbaab621954L, "FirstOrderLogic.structure.AndOperatorStatement"));
        SLinkOperations.setTarget(wrapper, LINKS.left$tEgL, ltr);
        SLinkOperations.setTarget(wrapper, LINKS.right$g53S, rtl);
        SNodeOperations.replaceWithAnother(equiv, wrapper);
        repeat = true;
      }
      if (!(show_message) && repeat) {
        show_message = true;
      }
    } while (repeat);

    if (show_message) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Substituting equivalences with implications", QueriesGenerated.class, null, null);
    }
  }
  public static void mappingScript_CodeBlock_7(final MappingScriptContext _context) {
    boolean show_message = false;

    for (SNode knows : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.KnowledgeBaseEntry$HX))) {
      boolean repeat;
      do {
        repeat = false;
        for (SNode and : ListSequence.fromList(SNodeOperations.getChildren(knows)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(it)), CONCEPTS.AndOperatorStatement$2T);
          }
        })) {
          repeat = true;
          SNodeOperations.insertPrevSiblingChild(and, SLinkOperations.getTarget(SNodeOperations.as(and, CONCEPTS.AndOperatorStatement$2T), LINKS.left$tEgL));
          SNodeOperations.replaceWithAnother(and, SLinkOperations.getTarget(SNodeOperations.as(and, CONCEPTS.AndOperatorStatement$2T), LINKS.right$g53S));
        }
        if (!(show_message) && repeat) {
          show_message = true;
        }
      } while (repeat);
    }

    if (show_message) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Splitting root conjunction statements", QueriesGenerated.class, null, null);
    }
  }
  public static void mappingScript_CodeBlock_11(final MappingScriptContext _context) {
    boolean show_message = false;
    boolean repeat;
    do {
      repeat = false;
      for (SNode quant : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.AllQuantifiedStatement$Ex))) {
        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(quant))), CONCEPTS.AOperatorStatement$ft) || SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(quant))), CONCEPTS.ExistsQuantifiedStatement$jU)) {
          SNode parent = SNodeOperations.as(SNodeOperations.getParent(quant), CONCEPTS.AStatement$1q);
          SNode copy = SNodeOperations.copyNode(quant);
          SNodeOperations.replaceWithAnother(quant, SLinkOperations.getTarget(quant, LINKS.statement$PMeT));
          SLinkOperations.setTarget(copy, LINKS.statement$PMeT, SNodeOperations.copyNode(parent));
          SNodeOperations.replaceWithAnother(parent, copy);
          repeat = true;
        }
      }
      if (!(show_message) && repeat) {
        show_message = true;
      }
    } while (repeat);

    do {
      repeat = false;
      for (SNode quant : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.ExistsQuantifiedStatement$jU))) {
        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(quant))), CONCEPTS.AOperatorStatement$ft)) {
          SNode parent = SNodeOperations.as(SNodeOperations.getParent(quant), CONCEPTS.AStatement$1q);
          SNode copy = SNodeOperations.copyNode(quant);
          SNodeOperations.replaceWithAnother(quant, SLinkOperations.getTarget(quant, LINKS.statement$PMeT));
          SLinkOperations.setTarget(copy, LINKS.statement$PMeT, SNodeOperations.copyNode(parent));
          SNodeOperations.replaceWithAnother(parent, copy);
          repeat = true;
        }
      }
      if (!(show_message) && repeat) {
        show_message = true;
      }
    } while (repeat);

    if (show_message) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Moving quantifiers outward", QueriesGenerated.class, null, null);
    }
  }
  public static void mappingScript_CodeBlock_12(final MappingScriptContext _context) {
    int cnt = 0;

    for (SNode exists : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.ExistsQuantifiedStatement$jU))) {
      for (final SNode var : ListSequence.fromList(SLinkOperations.getChildren(exists, LINKS.quantors$jFRS))) {
        SNode skolem = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00b217e4L, "FirstOrderLogic.structure.Function"));
        SPropertyOperations.assign(skolem, PROPS.name$MnvL, "skolem_function" + String.valueOf(cnt));

        SNode skolem_ref = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00b2183aL, "FirstOrderLogic.structure.FunctionReference"));
        SLinkOperations.setTarget(skolem_ref, LINKS.ref$3iQK, skolem);

        SNode parent = SNodeOperations.getParent(exists);
        while (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(parent)), CONCEPTS.ExistsQuantifiedStatement$jU)) {
          parent = SNodeOperations.getParent(parent);
        }
        while (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(parent)), CONCEPTS.AllQuantifiedStatement$Ex)) {
          for (SNode allvar : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.as(parent, CONCEPTS.AllQuantifiedStatement$Ex), LINKS.quantors$jFRS))) {
            SNode reference = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20cb7c36L, "FirstOrderLogic.structure.VariableReference"));
            SLinkOperations.setTarget(reference, LINKS.ref$3iQK, allvar);
            ListSequence.fromList(SLinkOperations.getChildren(skolem_ref, LINKS.parameters$Jqsy)).addElement(reference);
          }
          parent = SNodeOperations.getParent(parent);
        }

        SNode toReplaceWith;
        if (SLinkOperations.getChildren(skolem_ref, LINKS.parameters$Jqsy).size() > 0) {
          toReplaceWith = skolem_ref;
        } else {
          SNode constant = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00abee10L, "FirstOrderLogic.structure.Constant"));
          SPropertyOperations.assign(constant, PROPS.name$MnvL, "skolem_constant" + String.valueOf(cnt));
          SNode const_ref = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00b9b606L, "FirstOrderLogic.structure.ConstantReference"));
          SLinkOperations.setTarget(const_ref, LINKS.ref$3iQK, constant);
          toReplaceWith = const_ref;
        }

        for (SNode ref : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.VariableReference$al)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SPropertyOperations.getString(SLinkOperations.getTarget(it, LINKS.ref$3iQK), PROPS.name$MnvL) == SPropertyOperations.getString(var, PROPS.name$MnvL);
          }
        })) {
          SNodeOperations.replaceWithAnother(ref, SNodeOperations.copyNode(toReplaceWith));
        }
        cnt++;
      }
      SNodeOperations.replaceWithAnother(exists, SLinkOperations.getTarget(exists, LINKS.statement$PMeT));
    }

    if (cnt != 0) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Skolemizing existential quantifiers", QueriesGenerated.class, null, null);
    }
  }
  public static void mappingScript_CodeBlock_13(final MappingScriptContext _context) {
    boolean show_message = false;
    for (SNode know : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.KnowledgeBaseEntry$HX))) {
      boolean repeat;
      do {
        repeat = false;
        for (SNode quant : ListSequence.fromList(SNodeOperations.getChildren(know)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(it)), CONCEPTS.AllQuantifiedStatement$Ex);
          }
        })) {
          SNodeOperations.replaceWithAnother(quant, SLinkOperations.getTarget(SNodeOperations.as(quant, CONCEPTS.AllQuantifiedStatement$Ex), LINKS.statement$PMeT));
          repeat = true;
        }
        if (!(show_message) && repeat) {
          show_message = true;
        }
      } while (repeat);
    }
    if (show_message) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Dropping universal quantifiers", QueriesGenerated.class, null, null);
    }
  }
  public static void mappingScript_CodeBlock_14(final MappingScriptContext _context) {
    boolean show_message = false;
    boolean repeat;
    do {
      repeat = false;
      for (SNode or : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.OrOperatorStatement$L5))) {
        if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(or, LINKS.left$tEgL))), CONCEPTS.AndOperatorStatement$2T)) {
          // (a & b) v c --> (a v c) & (b v c) 
          SNode left = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928d5d80fL, "FirstOrderLogic.structure.OrOperatorStatement"));
          SNode right = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928d5d80fL, "FirstOrderLogic.structure.OrOperatorStatement"));
          SLinkOperations.setTarget(left, LINKS.left$tEgL, SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(or, LINKS.left$tEgL), CONCEPTS.AndOperatorStatement$2T), LINKS.left$tEgL)));
          SLinkOperations.setTarget(right, LINKS.left$tEgL, SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(or, LINKS.left$tEgL), CONCEPTS.AndOperatorStatement$2T), LINKS.right$g53S)));
          SLinkOperations.setTarget(left, LINKS.right$g53S, SNodeOperations.copyNode(SLinkOperations.getTarget(or, LINKS.right$g53S)));
          SLinkOperations.setTarget(right, LINKS.right$g53S, SNodeOperations.copyNode(SLinkOperations.getTarget(or, LINKS.right$g53S)));

          SNode outer = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x6996afbaab621954L, "FirstOrderLogic.structure.AndOperatorStatement"));
          SLinkOperations.setTarget(outer, LINKS.left$tEgL, left);
          SLinkOperations.setTarget(outer, LINKS.right$g53S, right);

          SNodeOperations.replaceWithAnother(or, outer);
          repeat = true;
        }
        if (SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(or, LINKS.right$g53S))), CONCEPTS.AndOperatorStatement$2T)) {
          // c v (a & b) --> (a v c) & (b v c) 
          SNode left = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928d5d80fL, "FirstOrderLogic.structure.OrOperatorStatement"));
          SNode right = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928d5d80fL, "FirstOrderLogic.structure.OrOperatorStatement"));
          SLinkOperations.setTarget(left, LINKS.left$tEgL, SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(or, LINKS.right$g53S), CONCEPTS.AndOperatorStatement$2T), LINKS.left$tEgL)));
          SLinkOperations.setTarget(right, LINKS.left$tEgL, SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(or, LINKS.right$g53S), CONCEPTS.AndOperatorStatement$2T), LINKS.right$g53S)));
          SLinkOperations.setTarget(left, LINKS.right$g53S, SNodeOperations.copyNode(SLinkOperations.getTarget(or, LINKS.left$tEgL)));
          SLinkOperations.setTarget(right, LINKS.right$g53S, SNodeOperations.copyNode(SLinkOperations.getTarget(or, LINKS.left$tEgL)));

          SNode outer = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x6996afbaab621954L, "FirstOrderLogic.structure.AndOperatorStatement"));
          SLinkOperations.setTarget(outer, LINKS.left$tEgL, left);
          SLinkOperations.setTarget(outer, LINKS.right$g53S, right);

          SNodeOperations.replaceWithAnother(or, outer);
          repeat = true;
        }
      }
      if (!(show_message) && repeat) {
        show_message = true;
      }
    } while (repeat);

    if (show_message) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Distributing v over ∧", QueriesGenerated.class, null, null);
    }
  }
  public static void mappingScript_CodeBlock_18(final MappingScriptContext _context) {
    boolean show_message = false;
    boolean repeat;
    do {
      repeat = false;
      for (SNode imp : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.ImpliesOperatorStatement$n3))) {
        SNode repl = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928d5d80fL, "FirstOrderLogic.structure.OrOperatorStatement"));
        SNode left = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, "FirstOrderLogic.structure.NegatedStatement"));
        SLinkOperations.setTarget(left, LINKS.statement$pxjq, SLinkOperations.getTarget(imp, LINKS.left$tEgL));
        SLinkOperations.setTarget(repl, LINKS.left$tEgL, left);
        SLinkOperations.setTarget(repl, LINKS.right$g53S, SLinkOperations.getTarget(imp, LINKS.right$g53S));
        SNodeOperations.replaceWithAnother(imp, repl);
        repeat = true;
      }
      if (!(show_message) && repeat) {
        show_message = true;
      }
    } while (repeat);

    if (show_message) {
      LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Substituting (a ⇒ b) with (¬a v b)", QueriesGenerated.class, null, null);
    }

  }
  public static void mappingScript_CodeBlock_19(final MappingScriptContext _context) {
    LoggingRuntime.logMsgView(Level.INFO, "Preprocessing: Building implications from CNF clauses where possible", QueriesGenerated.class, null, null);

    for (SNode root : ListSequence.fromList(SModelOperations.nodes(_context.getModel(), CONCEPTS.AStatement$1q)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(it))), CONCEPTS.KnowledgeBaseEntry$HX) && SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(it)), CONCEPTS.OrOperatorStatement$L5);
      }
    })) {

      SNode target = ListSequence.fromList(SNodeOperations.getNodeDescendants(root, CONCEPTS.AStatement$1q, false, new SAbstractConcept[]{})).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(it)), CONCEPTS.AAtomicStatement$Vv) && SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConcept(SNodeOperations.getParent(it))), CONCEPTS.OrOperatorStatement$L5);
        }
      }).first();

      if (ListSequence.fromList(SNodeOperations.getNodeDescendants(root, CONCEPTS.NegatedStatement$8l, false, new SAbstractConcept[]{})).isEmpty()) {
        LoggingRuntime.logMsgView(Level.WARN, "Preprocessing: CNF clause found with no negated literals. If your knowledge base doesn't contain " + "any extra information related to these literals, the prolog script may not function as expected!", QueriesGenerated.class, null, null);
        LoggingRuntime.logMsgView(Level.WARN, "Index of clause in its knowledge base is " + SNodeOperations.getIndexInParent(root), QueriesGenerated.class, null, null);
      } else if ((ListSequence.fromList(SNodeOperations.getNodeDescendants(root, CONCEPTS.NegatedStatement$8l, false, new SAbstractConcept[]{})).count() + 1) < ListSequence.fromList(SNodeOperations.getNodeDescendants(root, CONCEPTS.AAtomicStatement$Vv, false, new SAbstractConcept[]{})).count()) {
        LoggingRuntime.logMsgView(Level.WARN, "Preprocessing: CNF clause found with multiple positive literals. If your knowledge base doesn't contain " + "any extra information related to these literals, the prolog script may not function as expected!", QueriesGenerated.class, null, null);
        LoggingRuntime.logMsgView(Level.WARN, "Index of clause in its knowledge base is " + SNodeOperations.getIndexInParent(root), QueriesGenerated.class, null, null);

      }

      if ((target != null)) {
        SNode imp = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928f45d97L, "FirstOrderLogic.structure.ImpliesOperatorStatement"));
        SNode negated = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, "FirstOrderLogic.structure.NegatedStatement"));
        SLinkOperations.setTarget(imp, LINKS.left$tEgL, negated);
        SLinkOperations.setTarget(imp, LINKS.right$g53S, SNodeOperations.copyNode(target));

        SNode to_replace_with;
        if (target == SLinkOperations.getTarget(SNodeOperations.as(SNodeOperations.getParent(target), CONCEPTS.OrOperatorStatement$L5), LINKS.left$tEgL)) {
          to_replace_with = SLinkOperations.getTarget(SNodeOperations.as(SNodeOperations.getParent(target), CONCEPTS.OrOperatorStatement$L5), LINKS.right$g53S);
        } else {
          to_replace_with = SLinkOperations.getTarget(SNodeOperations.as(SNodeOperations.getParent(target), CONCEPTS.OrOperatorStatement$L5), LINKS.left$tEgL);
        }

        SNode ptr = root;
        if (SNodeOperations.getParent(target) == root) {
          ptr = to_replace_with;
        }
        SNodeOperations.replaceWithAnother(SNodeOperations.getParent(target), to_replace_with);

        SLinkOperations.setTarget(negated, LINKS.statement$pxjq, SNodeOperations.copyNode(ptr));
        SNodeOperations.replaceWithAnother(ptr, imp);
      } else {
        LoggingRuntime.logMsgView(Level.ERROR, "Preprocess error: Or statement found with no positive literals. Statements like this cannot be represented in prolog!", QueriesGenerated.class, null, null);
        throw new LinkageError("");
      }
    }
  }
  private final Map<String, ReductionRuleCondition> rrcMethods = new HashMap<String, ReductionRuleCondition>();
  {
    int i = 0;
    rrcMethods.put("8521472005505657412", new RRC(i++));
    rrcMethods.put("7771543041056948619", new RRC(i++));
  }
  @Override
  @NotNull
  public ReductionRuleCondition getReductionRuleCondition(@NotNull QueryKey identity) {
    final String id = identity.getTemplateNode().getNodeId().toString();
    if (!(rrcMethods.containsKey(id))) {
      return super.getReductionRuleCondition(identity);
    }
    return rrcMethods.get(id);
  }
  private static class RRC implements ReductionRuleCondition {
    private final int methodKey;
    public RRC(int methodKey) {
      this.methodKey = methodKey;
    }
    @Override
    public boolean check(ReductionRuleQueryContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.rule_Condition_16_0(ctx);
        case 1:
          return QueriesGenerated.rule_Condition_17_0(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no condition method for rule %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, ScriptCodeBlock> mscbMethods = new HashMap<String, ScriptCodeBlock>();
  {
    int i = 0;
    mscbMethods.put("7076127368651552628", new SCB(i++));
    mscbMethods.put("8525279030024589765", new SCB(i++));
    mscbMethods.put("8525279030027778944", new SCB(i++));
    mscbMethods.put("8525279030027815987", new SCB(i++));
    mscbMethods.put("8525279030027880008", new SCB(i++));
    mscbMethods.put("8525279030028713553", new SCB(i++));
    mscbMethods.put("8525279030029005393", new SCB(i++));
    mscbMethods.put("8525279030029006133", new SCB(i++));
    mscbMethods.put("7234254527726091017", new SCB(i++));
    mscbMethods.put("7771543041058970283", new SCB(i++));
    mscbMethods.put("7771543041059123846", new SCB(i++));
  }
  @Override
  @NotNull
  public ScriptCodeBlock getScriptCodeBlock(@NotNull QueryKey identity) {
    final String id = identity.getTemplateNode().getNodeId().toString();
    if (!(mscbMethods.containsKey(id))) {
      return super.getScriptCodeBlock(identity);
    }
    return mscbMethods.get(id);
  }
  private static class SCB implements ScriptCodeBlock {
    private final int methodKey;
    public SCB(int methodKey) {
      this.methodKey = methodKey;
    }
    @Override
    public void invoke(MappingScriptContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          QueriesGenerated.mappingScript_CodeBlock_2(ctx);
          return;
        case 1:
          QueriesGenerated.mappingScript_CodeBlock_3(ctx);
          return;
        case 2:
          QueriesGenerated.mappingScript_CodeBlock_5(ctx);
          return;
        case 3:
          QueriesGenerated.mappingScript_CodeBlock_6(ctx);
          return;
        case 4:
          QueriesGenerated.mappingScript_CodeBlock_7(ctx);
          return;
        case 5:
          QueriesGenerated.mappingScript_CodeBlock_11(ctx);
          return;
        case 6:
          QueriesGenerated.mappingScript_CodeBlock_12(ctx);
          return;
        case 7:
          QueriesGenerated.mappingScript_CodeBlock_13(ctx);
          return;
        case 8:
          QueriesGenerated.mappingScript_CodeBlock_14(ctx);
          return;
        case 9:
          QueriesGenerated.mappingScript_CodeBlock_18(ctx);
          return;
        case 10:
          QueriesGenerated.mappingScript_CodeBlock_19(ctx);
          return;
        default:
          throw new GenerationFailureException(String.format("There's no code block with method index %d ", methodKey));
      }
    }
  }
  private final Map<String, SourceNodeQuery> snqMethods = new HashMap<String, SourceNodeQuery>();
  {
    int i = 0;
    snqMethods.put("7771543041061947826", new SNQ(i++));
    snqMethods.put("7771543041061947531", new SNQ(i++));
    snqMethods.put("8525279030028484266", new SNQ(i++));
    snqMethods.put("8525279030028486948", new SNQ(i++));
    snqMethods.put("8525279030028656108", new SNQ(i++));
    snqMethods.put("8525279030028656416", new SNQ(i++));
    snqMethods.put("8521472005505654504", new SNQ(i++));
    snqMethods.put("8521472005505654833", new SNQ(i++));
    snqMethods.put("7771543041056539736", new SNQ(i++));
    snqMethods.put("7771543041056954882", new SNQ(i++));
    snqMethods.put("7771543041056956688", new SNQ(i++));
  }
  @NotNull
  @Override
  public SourceNodeQuery getSourceNodeQuery(@NotNull QueryKey identity) {
    final String id = ((QueryKeyImpl) identity).getQueryNodeId().toString();
    if (!(snqMethods.containsKey(id))) {
      return super.getSourceNodeQuery(identity);
    }
    return snqMethods.get(id);
  }
  private static class SNQ implements SourceNodeQuery {
    private final int methodKey;
    public SNQ(int methodKey) {
      this.methodKey = methodKey;
    }
    @Nullable
    public SNode evaluate(@NotNull SourceSubstituteMacroNodeContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.sourceNodeQuery_0_0(ctx);
        case 1:
          return QueriesGenerated.sourceNodeQuery_0_1(ctx);
        case 2:
          return QueriesGenerated.sourceNodeQuery_8_0(ctx);
        case 3:
          return QueriesGenerated.sourceNodeQuery_8_1(ctx);
        case 4:
          return QueriesGenerated.sourceNodeQuery_10_0(ctx);
        case 5:
          return QueriesGenerated.sourceNodeQuery_10_1(ctx);
        case 6:
          return QueriesGenerated.sourceNodeQuery_15_0(ctx);
        case 7:
          return QueriesGenerated.sourceNodeQuery_15_1(ctx);
        case 8:
          return QueriesGenerated.sourceNodeQuery_16_0(ctx);
        case 9:
          return QueriesGenerated.sourceNodeQuery_17_0(ctx);
        case 10:
          return QueriesGenerated.sourceNodeQuery_17_1(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, SourceNodesQuery> snsqMethods = new HashMap<String, SourceNodesQuery>();
  {
    int i = 0;
    snsqMethods.put("2964349057850472703", new SNsQ(i++));
    snsqMethods.put("2964349057850314853", new SNsQ(i++));
    snsqMethods.put("8525279030025584257", new SNsQ(i++));
    snsqMethods.put("8525279030026061249", new SNsQ(i++));
    snsqMethods.put("8525279030028654839", new SNsQ(i++));
  }
  @NotNull
  @Override
  public SourceNodesQuery getSourceNodesQuery(@NotNull QueryKey identity) {
    final String id = ((QueryKeyImpl) identity).getQueryNodeId().toString();
    if (!(snsqMethods.containsKey(id))) {
      return super.getSourceNodesQuery(identity);
    }
    return snsqMethods.get(id);
  }
  private static class SNsQ implements SourceNodesQuery {
    private final int methodKey;
    public SNsQ(int methodKey) {
      this.methodKey = methodKey;
    }
    @NotNull
    public Collection<SNode> evaluate(@NotNull SourceSubstituteMacroNodesContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_0_0(ctx));
        case 1:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_1_0(ctx));
        case 2:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_1_1(ctx));
        case 3:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_4_0(ctx));
        case 4:
          return IterableUtil.asCollection(QueriesGenerated.sourceNodesQuery_9_0(ctx));
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, PropertyValueQuery> pvqMethods = new HashMap<String, PropertyValueQuery>();
  {
    int i = 0;
    pvqMethods.put("2964349057851050737", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), null));
    pvqMethods.put("2964349057851051355", new PVQ(i++, MetaAdapterFactory.getProperty(0xc89da2859ac54e3cL, 0x9fcfeb4b39236f25L, 0x29237bc3276d06d4L, 0x29237bc3277744f9L, "arity"), null));
    pvqMethods.put("2964349057851052180", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), null));
    pvqMethods.put("2964349057851052798", new PVQ(i++, MetaAdapterFactory.getProperty(0xc89da2859ac54e3cL, 0x9fcfeb4b39236f25L, 0x29237bc3276d06d4L, 0x29237bc3277744f9L, "arity"), null));
    pvqMethods.put("2964349057850462695", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), null));
    pvqMethods.put("2964349057851140178", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), null));
    pvqMethods.put("2964349057850468520", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), null));
    pvqMethods.put("8525279030027692876", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "map_Sheet"));
    pvqMethods.put("8525279030026690517", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "name"));
    pvqMethods.put("8525279030028650743", new PVQ(i++, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "name"));
  }
  @NotNull
  @Override
  public PropertyValueQuery getPropertyValueQuery(@NotNull QueryKey identity) {
    final String id = identity.getTemplateNode().getNodeId().toString();
    if (!(pvqMethods.containsKey(id))) {
      return super.getPropertyValueQuery(identity);
    }
    return pvqMethods.get(id);
  }
  private static class PVQ extends PropertyValueQuery.Base {
    private final int methodKey;
    /*package*/ PVQ(int methodKey, SProperty property, String templateValue) {
      super(property, templateValue);
      this.methodKey = methodKey;
    }
    @Nullable
    public Object evaluate(@NotNull PropertyMacroContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.propertyMacro_GetValue_0_0(ctx);
        case 1:
          return QueriesGenerated.propertyMacro_GetValue_0_1(ctx);
        case 2:
          return QueriesGenerated.propertyMacro_GetValue_0_2(ctx);
        case 3:
          return QueriesGenerated.propertyMacro_GetValue_0_3(ctx);
        case 4:
          return QueriesGenerated.propertyMacro_GetValue_0_4(ctx);
        case 5:
          return QueriesGenerated.propertyMacro_GetValue_0_5(ctx);
        case 6:
          return QueriesGenerated.propertyMacro_GetValue_0_6(ctx);
        case 7:
          return QueriesGenerated.propertyMacro_GetValue_1_0(ctx);
        case 8:
          return QueriesGenerated.propertyMacro_GetValue_4_0(ctx);
        case 9:
          return QueriesGenerated.propertyMacro_GetValue_9_0(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no method for query %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private final Map<String, InlineSwitchCaseCondition> isccMethods = new HashMap<String, InlineSwitchCaseCondition>();
  {
    int i = 0;
    isccMethods.put("8525279030027034672", new ISCC(i++));
    isccMethods.put("8525279030028655831", new ISCC(i++));
  }
  @NotNull
  @Override
  public InlineSwitchCaseCondition getInlineSwitchCaseCondition(@NotNull QueryKey identity) {
    final String id = identity.getTemplateNode().getNodeId().toString();
    if (!(isccMethods.containsKey(id))) {
      return super.getInlineSwitchCaseCondition(identity);
    }
    return isccMethods.get(id);
  }
  private static class ISCC implements InlineSwitchCaseCondition {
    private final int methodKey;
    public ISCC(int methodKey) {
      this.methodKey = methodKey;
    }
    @Override
    public boolean check(@NotNull InlineSwitchCaseContext ctx) throws GenerationFailureException {
      switch (methodKey) {
        case 0:
          return QueriesGenerated.rule_Condition_0_0(ctx);
        case 1:
          return QueriesGenerated.rule_Condition_0_1(ctx);
        default:
          throw new GenerationFailureException(String.format("Inconsistent QueriesGenerated: there's no condition method for inline switch's case %s (key: #%d)", ctx.getTemplateReference(), methodKey));
      }
    }
  }
  private static final ConceptSwitchIndex conceptIndex = new ConceptSwitchIndexBuilder().put(MetaIdFactory.conceptId(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20c99906L), MetaIdFactory.conceptId(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x6996afbaab621954L), MetaIdFactory.conceptId(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x1bf6498e1734c76cL), MetaIdFactory.conceptId(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L), MetaIdFactory.conceptId(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928d5d80fL)).seal();

  private static final class CONCEPTS {
    /*package*/ static final SConcept KnowledgeBaseEntry$HX = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x636efe58094cc959L, "FirstOrderLogic.structure.KnowledgeBaseEntry");
    /*package*/ static final SConcept NegatedStatement$8l = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, "FirstOrderLogic.structure.NegatedStatement");
    /*package*/ static final SConcept OrOperatorStatement$L5 = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928d5d80fL, "FirstOrderLogic.structure.OrOperatorStatement");
    /*package*/ static final SConcept PredicateListEntry$jl = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x41354ec0cdeaf521L, "FirstOrderLogic.structure.PredicateListEntry");
    /*package*/ static final SConcept FunctionListEntry$3y = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00b32488L, "FirstOrderLogic.structure.FunctionListEntry");
    /*package*/ static final SConcept AllQuantifiedStatement$Ex = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20c99906L, "FirstOrderLogic.structure.AllQuantifiedStatement");
    /*package*/ static final SConcept AndOperatorStatement$2T = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x6996afbaab621954L, "FirstOrderLogic.structure.AndOperatorStatement");
    /*package*/ static final SConcept ExistsQuantifiedStatement$jU = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x1bf6498e1734c76cL, "FirstOrderLogic.structure.ExistsQuantifiedStatement");
    /*package*/ static final SConcept ParenthesesStatement$zg = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2ccfec9L, "FirstOrderLogic.structure.ParenthesesStatement");
    /*package*/ static final SConcept EqualsOperatorStatement$S_ = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928f45dd7L, "FirstOrderLogic.structure.EqualsOperatorStatement");
    /*package*/ static final SConcept AOperatorStatement$ft = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20c7b087L, "FirstOrderLogic.structure.AOperatorStatement");
    /*package*/ static final SConcept AStatement$1q = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20c7b07fL, "FirstOrderLogic.structure.AStatement");
    /*package*/ static final SConcept VariableReference$al = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20cb7c36L, "FirstOrderLogic.structure.VariableReference");
    /*package*/ static final SConcept ImpliesOperatorStatement$n3 = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5d4b7b1928f45d97L, "FirstOrderLogic.structure.ImpliesOperatorStatement");
    /*package*/ static final SConcept AAtomicStatement$Vv = MetaAdapterFactory.getConcept(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x41354ec0cded1c6cL, "FirstOrderLogic.structure.AAtomicStatement");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty arity$TURW = MetaAdapterFactory.getProperty(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00b217e4L, 0x5c35fb00b217e7L, "arity");
    /*package*/ static final SProperty arity$91hq = MetaAdapterFactory.getProperty(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x41354ec0cdeac250L, 0x41354ec0cdeac251L, "arity");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink ref$3iQK = MetaAdapterFactory.getReferenceLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00b21835L, 0x1474d1fc6f086922L, "ref");
    /*package*/ static final SReferenceLink predicate$FL91 = MetaAdapterFactory.getReferenceLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x523a606984019bbaL, 0x523a606984019bc2L, "predicate");
    /*package*/ static final SContainmentLink left$tEgL = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20c7b087L, 0x13ba598d20c7b08aL, "left");
    /*package*/ static final SContainmentLink right$g53S = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20c7b087L, 0x13ba598d20ca3ae6L, "right");
    /*package*/ static final SContainmentLink term1$Q5Mf = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x636efe58094ad65bL, 0x636efe58094ad65cL, "term1");
    /*package*/ static final SContainmentLink term2$Q6gh = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x636efe58094ad65bL, 0x636efe58094ad65eL, "term2");
    /*package*/ static final SContainmentLink statement$pxjq = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2c8dae6L, 0x36e551eaf2c8dae7L, "statement");
    /*package*/ static final SContainmentLink parameters$Jqsy = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00b2183aL, 0x5c35fb00b7f555L, "parameters");
    /*package*/ static final SContainmentLink predicates$26Nq = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x41354ec0cdeaf521L, 0x41354ec0cdeaf522L, "predicates");
    /*package*/ static final SContainmentLink content$_J4j = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00ac843eL, 0x5c35fb00ac8464L, "content");
    /*package*/ static final SContainmentLink functions$euTU = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x5c35fb00b32488L, 0x5c35fb00b32489L, "functions");
    /*package*/ static final SContainmentLink statements$MO7q = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x636efe58094cc959L, 0x636efe58094cc95aL, "statements");
    /*package*/ static final SContainmentLink parameters$Ifhz = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x523a606984019bbaL, 0x523a606984019bc4L, "parameters");
    /*package*/ static final SContainmentLink quantors$jFRS = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20c998f8L, 0x13ba598d20c99902L, "quantors");
    /*package*/ static final SContainmentLink statement$PMeT = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x13ba598d20c998f8L, 0x13ba598d20ca3aebL, "statement");
    /*package*/ static final SContainmentLink statement$TjGf = MetaAdapterFactory.getContainmentLink(0x5d8a3d04c5e547e4L, 0x806d03da42a8c2cbL, 0x36e551eaf2ccfec9L, 0x36e551eaf2ccfecaL, "statement");
  }
}
